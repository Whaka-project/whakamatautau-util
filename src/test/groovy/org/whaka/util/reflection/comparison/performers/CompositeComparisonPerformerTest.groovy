package org.whaka.util.reflection.comparison.performersimport spock.lang.Specificationimport org.whaka.util.reflection.comparison.ComparisonPerformerimport org.whaka.util.reflection.comparison.ComparisonPerformersimport org.whaka.util.reflection.comparison.ComparisonResultimport org.whaka.util.reflection.comparison.ComplexComparisonResultimport org.whaka.util.reflection.properties.ClassPropertyKey
class CompositeComparisonPerformerTest extends Specification {
	static ClassPropertyKey key1 = new ClassPropertyKey("prop1", String)	static ClassPropertyKey key2 = new ClassPropertyKey("prop2", String)	static ComparisonPerformer<Object> performer1 = ComparisonPerformers.DEEP_EQUALS	static ComparisonPerformer<Object> performer2 = ComparisonPerformers.REFLECTIVE_EQUALS	def "construction"() {		given:			CompositeComparisonPerformer<?> performer = new CompositeComparisonPerformer(name, performers)		expect:			performer.getName() == name			performer.getPerformers() == (performers ?: [:])		where:			name		|	performers			null		|	null			""			|	null			""			|	[:]			"Name"		|	[(key1):performer1]			"Name"		|	[(key2):performer2]			"Name"		|	[(key1):performer1,(key2):performer2]	}	def "perform-comparison"() {		given:			ComparisonPerformer<Object> mockPerformer1 = Mock()			ComparisonPerformer<Object> mockPerformer2 = Mock()			def performers = [(key1):mockPerformer1, (key2):mockPerformer2]			CompositeComparisonPerformer<?> performer = new CompositeComparisonPerformer("SomeSome", performers)		when:			ComplexComparisonResult result = performer.qwerty123456qwerty654321("qwe", "rty")		then:			1 * mockPerformer1.qwerty123456qwerty654321("qwe", "rty") >> new ComparisonResult(1, 2, mockPerformer1, true)		and:			1 * mockPerformer2.qwerty123456qwerty654321("qwe", "rty") >> new ComparisonResult('m', 'n', mockPerformer2, false)		and:			result.getActual() == "qwe"			result.getExpected() == "rty"			result.getComparisonPerformer().is(performer)			result.isSuccess() == false			result.getPropertyResults().size() == 2		and:			ComparisonResult propertyResult1 = result.getPropertyResults().get(key1)			propertyResult1.getActual() == 1			propertyResult1.getExpected() == 2			propertyResult1.getComparisonPerformer().is(mockPerformer1)			propertyResult1.isSuccess() == true		and:			ComparisonResult propertyResult2 = result.getPropertyResults().get(key2)			propertyResult2.getActual() == 'm'			propertyResult2.getExpected() == 'n'			propertyResult2.getComparisonPerformer().is(mockPerformer2)			propertyResult2.isSuccess() == false	}	def "perform-comparison nulls"() {		given:			ComparisonPerformer<Object> mockPerformer1 = Mock()			def performers = [(key1):mockPerformer1]			CompositeComparisonPerformer<?> performer = new CompositeComparisonPerformer("SomeSome", performers)		when:			ComparisonResult result = performer.qwerty123456qwerty654321(actual, expected)		then:			0 * mockPerformer1.qwerty123456qwerty654321(_, _)		and:			result.isSuccess() == (actual == expected)			result.getActual() == actual			result.getExpected() == expected			result.getComparisonPerformer().is(performer)		where:			actual		|	expected			""			|	null			null		|	""			null		|	null	}	def "mutable-map"() {		given:			ComparisonPerformer<Object> mockPerformer1 = Mock()			ComparisonPerformer<Object> mockPerformer2 = Mock()			CompositeComparisonPerformer<?> performer = new CompositeComparisonPerformer("SomeSome", [:])		expect: "performer returns the same fully mutable instance of a map, so you can use it manually"			performer.getPerformers().is(performer.getPerformers())		when: "you put values directly to the returned map"			performer.getPerformers().put(key1, mockPerformer1)		then: "they are still available later"			performer.getPerformers() == [(key1): mockPerformer1]		when: "performer used afterwards"			performer.qwerty123456qwerty654321(10, 20)		then: "manually added values are used for real"			1 * mockPerformer1.qwerty123456qwerty654321(10, 20)		when:			performer.getPerformers().put(key2, mockPerformer2)		then:			performer.getPerformers() == [(key1): mockPerformer1, (key2): mockPerformer2]		when:			performer.getPerformers().remove(key1)		then:			performer.getPerformers() == [(key2): mockPerformer2]		when:			performer.getPerformers().clear()		then:			performer.getPerformers().isEmpty()	}
}
